// =============================================================================
// TITAN CRDT LOCAL LEDGER SCHEMA (SQLite Compatible)
// =============================================================================
// Conflict-free Replicated Data Type (CRDT) schema for offline resilience.
// Allows autonomous operation when cloud connection is severed, with automatic
// reconciliation when connection is restored.
//
// EU AI Act Article 14 Compliance:
// - Immutable audit trail for all decisions
// - Human oversight interface
// - Kill switch state tracking
//
// NOTE: SQLite doesn't support native enums, so we use String with comments

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma-client"
}

datasource db {
  // SQLite for local-first operation (can sync to PostgreSQL via CRDT)
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// =============================================================================
// CORE TRADING MODELS
// =============================================================================

/// Immutable record of every AI trading decision
model Decision {
  id              String   @id @default(cuid())
  
  // Decision details
  // action: BUY | SELL | HOLD | HALT
  action          String
  confidence      Float
  reasoning       String
  // source: MATH_GUARDIAN | NEURAL_CORTEX | SYMBOLIC_CONSENSUS | EMERGENCY_HALT | MOA_CONSENSUS
  source          String
  proofHash       String   @unique
  
  // Market context at decision time
  symbol          String
  price           Float
  rsi             Float?
  ofi             Float?
  volatility      Float?
  trendStrength   Float?
  
  // Neural input (if available)
  neuralAction    String?
  neuralConfidence Float?
  
  // Execution status
  canExecute      Boolean  @default(false)
  wasExecuted     Boolean  @default(false)
  executedOrderId String?
  
  // CRDT fields for offline sync
  vectorClock     Int      @default(0)
  nodeId          String   @default("local")
  // syncStatus: PENDING | SYNCED | CONFLICT | LOCAL_ONLY
  syncStatus      String   @default("PENDING")
  
  // Timestamps
  createdAt       DateTime @default(now())
  syncedAt        DateTime?
  
  // Relations
  execution       Execution?
  auditLog        AuditLog[]
  
  @@index([createdAt])
  @@index([syncStatus])
  @@index([symbol])
}

/// Trade execution record with blockchain proof
model Execution {
  id              String   @id @default(cuid())
  
  // Link to decision
  decisionId      String   @unique
  decision        Decision @relation(fields: [decisionId], references: [id])
  
  // Exchange details
  exchangeOrderId String
  symbol          String
  // side: BUY | SELL | HOLD | HALT
  side            String
  quantity        Float
  entryPrice      Float
  
  // Risk management
  stopLossPrice   Float?
  takeProfitPrice Float?
  
  // Outcome tracking
  // status: PENDING | FILLED | PARTIALLY_FILLED | CANCELLED | CLOSED_TP | CLOSED_SL | CLOSED_MANUAL | FAILED
  status          String   @default("PENDING")
  exitPrice       Float?
  realizedPnl     Float?
  closedAt        DateTime?
  
  // Blockchain verification
  txHashL2        String?          // Base Sepolia
  txHashL1        String?          // Ethereum Sepolia
  blockNumber     Int?
  
  // CRDT fields
  vectorClock     Int      @default(0)
  nodeId          String   @default("local")
  syncStatus      String   @default("PENDING")
  
  // Timestamps
  createdAt       DateTime @default(now())
  
  @@index([symbol])
  @@index([status])
  @@index([createdAt])
}

/// Position tracking for portfolio management
model Position {
  id              String   @id @default(cuid())
  
  // Position details
  symbol          String   @unique
  // side: BUY | SELL | HOLD | HALT
  side            String
  entryPrice      Float
  currentQuantity Float
  averagePrice    Float
  
  // Unrealized PnL (updated on each tick)
  currentPrice    Float?
  unrealizedPnl   Float?
  
  // Risk limits
  maxQuantity     Float    @default(1.0)
  stopLossPrice   Float?
  
  // CRDT fields
  vectorClock     Int      @default(0)
  lastUpdated     DateTime @updatedAt
  
  @@index([symbol])
}

/// Kill switch state (EU AI Act compliance)
model KillSwitch {
  id              String   @id @default("singleton")
  
  isActive        Boolean  @default(false)
  activatedBy     String?
  activationReason String?
  activatedAt     DateTime?
  
  deactivatedBy   String?
  deactivatedAt   DateTime?
  
  // Audit trail
  activationCount Int      @default(0)
  
  updatedAt       DateTime @updatedAt
}

/// Immutable audit log (EU AI Act Article 14)
model AuditLog {
  id              String   @id @default(cuid())
  
  // Event details
  // eventType: DECISION_MADE | TRADE_EXECUTED | KILL_SWITCH_ACTIVATED | KILL_SWITCH_DEACTIVATED | NEURAL_VETO | MATH_OVERRIDE | LATENCY_HALT | VOLATILITY_HALT | SYNC_CONFLICT | SYSTEM_ERROR
  eventType       String
  // severity: DEBUG | INFO | WARN | ERROR | CRITICAL
  severity        String
  message         String
  metadata        String?          // JSON blob
  
  // Context
  decisionId      String?
  decision        Decision? @relation(fields: [decisionId], references: [id])
  
  // Source identification
  source          String   // e.g., "WASM_MATH_GUARDIAN", "NEURAL_CORTEX"
  nodeId          String   @default("local")
  
  // CRDT (append-only, no conflicts)
  vectorClock     Int      @default(0)
  
  createdAt       DateTime @default(now())
  
  @@index([eventType])
  @@index([createdAt])
  @@index([severity])
}

/// Micro-agent votes for MoA consensus
model AgentVote {
  id              String   @id @default(cuid())
  
  // Vote details
  // agentType: TREND_AGENT | VOLATILITY_AGENT | SENTIMENT_AGENT | QUANT_AGENT | RISK_AGENT | META_AGGREGATOR
  agentType       String
  // action: BUY | SELL | HOLD | HALT
  action          String
  confidence      Float
  reasoning       String
  
  // Context
  symbol          String
  price           Float
  timestamp       DateTime @default(now())
  
  // Link to final decision (many votes -> one decision)
  decisionId      String?
  
  @@index([timestamp])
  @@index([agentType])
}

/// Network health metrics for latency monitoring
model NetworkHealth {
  id              String   @id @default(cuid())
  
  // Latency measurements
  exchangeLatencyMs Int
  rpcLatencyMs      Int?
  aiLatencyMs       Int?
  
  // Status
  isHealthy       Boolean  @default(true)
  haltReason      String?
  
  createdAt       DateTime @default(now())
  
  @@index([createdAt])
}
